<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="妄言妄语当不得真,疯言疯语不足为信"><title>redis对象 | 吃饭不喝汤</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">redis对象</h1><a id="logo" href="/.">吃饭不喝汤</a><p class="description">饿了就吃饭渴了就喝水</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">redis对象</h1><div class="post-meta">Jul 21, 2019</div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#string"><span class="toc-number">1.</span> <span class="toc-text">string</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hash"><span class="toc-number">2.</span> <span class="toc-text">hash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#list"><span class="toc-number">3.</span> <span class="toc-text">list</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#set"><span class="toc-number">4.</span> <span class="toc-text">set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sorted-set"><span class="toc-number">5.</span> <span class="toc-text">sorted set</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#排行榜应用，取TOP-N操作"><span class="toc-number">5.1.</span> <span class="toc-text">排行榜应用，取TOP N操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#范围查找"><span class="toc-number">5.2.</span> <span class="toc-text">范围查找</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pub-Sub"><span class="toc-number">6.</span> <span class="toc-text">Pub/Sub</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场景"><span class="toc-number">6.1.</span> <span class="toc-text">使用场景</span></a></li></ol></li></ol></div></div><div class="post-content"><p><a href="https://www.cnblogs.com/yy1234/p/7809551.html" target="_blank" rel="noopener">refer</a></p>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。<br>常规key-value缓存应用；<br>常规计数：微博数，粉丝数等。</p>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。<br>存储部分变更的数据，如用户信息等。</p>
<h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><p>list就是链表，略有数据结构知识的人都应该能理解其结构。使用Lists结构，我们可以轻松地实现最新消息排行等功能。List的另一个应用就是消息队列，可以利用List的PUSH操作，将任务存在List中，然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作List中某一段的api，你可以直接查询，删除List中某一段的元素。<br>Redis的list是每个子元素都是String类型的双向链表，可以通过push和pop操作从列表的头部或者尾部添加或者删除元素，这样List即可以作为栈，也可以作为队列。</p>
<ul>
<li><p>消息队列系统<br>使用list可以构建队列系统，使用sorted set甚至可以构建有优先级的队列系统。<br>比如：将Redis用作日志收集器<br>实际上还是一个队列，多个端点将日志信息写入Redis，然后一个worker统一将所有日志写到磁盘。</p>
</li>
<li><p>取最新N个数据的操作</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//把当前登录人添加到链表里</span><br><span class="line">ret = r.lpush(&quot;login:last_login_times&quot;, uid)</span><br><span class="line">//保持链表只有N位</span><br><span class="line">ret = redis.ltrim(&quot;login:last_login_times&quot;, 0, N-1)</span><br><span class="line">//获得前N个最新登陆的用户Id列表</span><br><span class="line">last_login_list = r.lrange(&quot;login:last_login_times&quot;, 0, N-1)</span><br></pre></td></tr></table></figure>
<p>比如sina微博:<br>在Redis中我们的最新微博ID使用了常驻缓存，这是一直更新的。但是做了限制不能超过5000个ID，因此获取ID的函数会一直询问Redis。只有在start/count参数超出了这个范围的时候，才需要去访问数据库。<br>系统不会像传统方式那样“刷新”缓存，Redis实例中的信息永远是一致的。SQL数据库（或是硬盘上的其他类型数据库）只是在用户需要获取“很远”的数据时才会被触发，而主页或第一个评论页是不会麻烦到硬盘上的数据库了。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set就是一个集合，集合的概念就是一堆不重复值的组合。利用Redis提供的set数据结构，可以存储一些集合性的数据。set中的元素是没有顺序的。<br>案例： </p>
<p>在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的命令选择将结果返回给客户端还是存集到一个新的集合中。</p>
<p>交集，并集，差集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//book表存储book名称</span><br><span class="line">set book:1:name &quot;The Ruby Programming Language&quot;</span><br><span class="line">set book:2:name &quot;Ruby on rail&quot;</span><br><span class="line">set book:3:name &quot;Programming Erlang&quot;</span><br><span class="line"></span><br><span class="line">//tag表使用集合来存储数据，因为集合擅长求交集、并集</span><br><span class="line">sadd tag:ruby 1</span><br><span class="line">sadd tag:ruby 2</span><br><span class="line">sadd tag:web 2</span><br><span class="line">sadd tag:erlang 3</span><br><span class="line"></span><br><span class="line">//即属于ruby又属于web的书？</span><br><span class="line"> inter_list = redis.sinter(&quot;tag:web&quot;, &quot;tag:ruby&quot;)</span><br><span class="line">//即属于ruby，但不属于web的书？</span><br><span class="line"> diff_list = redis.sdiff(&quot;tag:ruby&quot;, &quot;tag:web&quot;)</span><br><span class="line">//属于ruby和属于web的书的合集？</span><br><span class="line"> union_list = redis.sunion(&quot;tag:ruby&quot;, &quot;tag:web&quot;)</span><br></pre></td></tr></table></figure>
<p>获取某段时间所有数据去重值<br>这个使用Redis的set数据结构最合适了，只需要不断地将数据往set中扔就行了，set意为集合，所以会自动排重。</p>
<h2 id="sorted-set"><a href="#sorted-set" class="headerlink" title="sorted set"></a>sorted set</h2><p>和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，比如一个存储全班同学成绩的sorted set，其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。可以用sorted set来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。</p>
<h3 id="排行榜应用，取TOP-N操作"><a href="#排行榜应用，取TOP-N操作" class="headerlink" title="排行榜应用，取TOP N操作"></a>排行榜应用，取TOP N操作</h3><p>这个需求与上面需求的不同之处在于，前面操作以时间为权重，这个是以某个条件为权重，比如按顶的次数排序，这时候就需要我们的sorted set出马了，将你要排序的值设置成sorted set的score，将具体的数据设置成相应的value，每次只需要执行一条ZADD命令即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//将登录次数和用户统一存储在一个sorted set里</span><br><span class="line">zadd login:login_times 5 1</span><br><span class="line">zadd login:login_times 1 2</span><br><span class="line">zadd login:login_times 2 3</span><br><span class="line"></span><br><span class="line">//当用户登录时，对该用户的登录次数自增1</span><br><span class="line">ret = r.zincrby(&quot;login:login_times&quot;, 1, uid)</span><br><span class="line">//那么如何获得登录次数最多的用户呢，逆序排列取得排名前N的用户</span><br><span class="line">ret = r.zrevrange(&quot;login:login_times&quot;, 0, N-1)</span><br></pre></td></tr></table></figure>
<p>比如在线游戏的排行榜，根据得分你通常想要：</p>
<pre><code>- 列出前100名高分选手

- 列出某用户当前的全球排名
</code></pre><p>这些操作对于Redis来说小菜一碟，即使你有几百万个用户，每分钟都会有几百万个新的得分。<br>模式是这样的，每次获得新得分时，我们用这样的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ZADD leaderboard &lt;score&gt; &lt;username&gt;</span><br><span class="line">你可能用userID来取代username，这取决于你是怎么设计的。 </span><br><span class="line">得到前100名高分用户很简单：</span><br><span class="line">ZREVRANGE leaderboard 0 99</span><br><span class="line">用户的全球排名也相似，只需要：</span><br><span class="line">ZRANK leaderboard &lt;username&gt;</span><br></pre></td></tr></table></figure></p>
<p>需要精准设定过期时间的应用<br>比如你可以把上面说到的sorted set的score值设置成过期时间的时间戳，那么就可以简单地通过过期时间排序，定时清除过期数据了，不仅是清除Redis中的过期数据，你完全可以把Redis里这个过期时间当成是对数据库中数据的索引，用Redis来找出哪些数据需要过期删除，然后再精准地从数据库中删除相应的记录。</p>
<h3 id="范围查找"><a href="#范围查找" class="headerlink" title="范围查找"></a>范围查找</h3><p>来自Redis在Google Group上的一个问题，有一位同学发贴求助，说要解决如下的一个问题：他有一个IP范围对应地址的列表，现在需要给出一个IP的情况下，迅速的查找到这个IP在哪个范围，也就是要判断此IP的所有地。这个问题引来了Redis作者Salvatore Sanfilippo（@antirez）的回答。解答如下:</p>
<p>例如有下面两个范围，10－20和30－40</p>
<ul>
<li>A_start 10, A_end 20 </li>
<li>B_start 30, B_end 40 </li>
</ul>
<p>我们将这两个范围的起始位置存在Redis的sorted set数据结构中，基本范围起始值作为score，范围名加start和end为其value值：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; zadd ranges 10 A_start</span><br><span class="line">redis 127.0.0.1:6379&gt; zadd ranges 20 A_end</span><br><span class="line">redis 127.0.0.1:6379&gt; zadd ranges 30 B_start</span><br><span class="line">redis 127.0.0.1:6379&gt; zadd ranges 40 B_end</span><br></pre></td></tr></table></figure>
<p>这样数据在插入sorted set后，相当于是将这些起始位置按顺序排列好了。<br>现在我需要查找15这个值在哪一个范围中，只需要进行如下的zrangbyscore查找：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; zrangebyscore ranges (15 +inf LIMIT 0 1</span><br><span class="line">1) <span class="string">"A_end"</span></span><br></pre></td></tr></table></figure>
<p>这个命令的意思是在Sorted Sets中查找大于15的第一个值。（+inf在Redis中表示正无穷大，15前面的括号表示&gt;15而非&gt;=15）<br>查找的结果是A_end，由于所有值是按顺序排列的，所以可以判定15是在A_start到A_end区间上，也就是说15是在A这个范围里。至此大功告成。<br>当然，如果你查找到的是一个start，比如咱们用25，执行下面的命令:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; zrangebyscore ranges (25 +inf LIMIT 0 1</span><br><span class="line">1) <span class="string">"B_start"</span></span><br></pre></td></tr></table></figure>
<p>返回结果表明其下一个节点是一个start节点，也就是说25这个值不处在任何start和end之间，不属于任何范围。<br>当然，这个例子仅适用于类似上面的IP范围查找的案例，因为这些值范围之间没有重合。如果是有重合的情况，这个问题本身也就变成了一个一对多的问题。</p>
<h2 id="Pub-Sub"><a href="#Pub-Sub" class="headerlink" title="Pub/Sub"></a>Pub/Sub</h2><p>Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>Pub/Sub构建实时消息系统</p>
<p>Redis的Pub/Sub系统可以构建实时的消息系统<br>比如很多用Pub/Sub构建的实时聊天系统的例子。</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/redis基本操作/">redis基本操作</a><a class="next" href="/redis数据结构/">redis数据结构</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/源码解读/" style="font-size: 15px;">源码解读</a> <a href="/tags/es/" style="font-size: 15px;">es</a> <a href="/tags/flask/" style="font-size: 15px;">flask</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/flask源码/" style="font-size: 15px;">flask源码</a> <a href="/tags/flask路由/" style="font-size: 15px;">flask路由</a> <a href="/tags/k8s/" style="font-size: 15px;">k8s</a> <a href="/tags/路由寻址/" style="font-size: 15px;">路由寻址</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/脚本/" style="font-size: 15px;">脚本</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/常用函数/" style="font-size: 15px;">常用函数</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a> <a href="/tags/消息队列/" style="font-size: 15px;">消息队列</a> <a href="/tags/tcp协议/" style="font-size: 15px;">tcp协议</a> <a href="/tags/开发环境配置/" style="font-size: 15px;">开发环境配置</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/转载-国内比较有名的自动驾驶公司/">转载___国内比较有名的自动驾驶公司</a></li><li class="post-list-item"><a class="post-list-link" href="/高并发优化的一些经验/">高并发优化的一些经验</a></li><li class="post-list-item"><a class="post-list-link" href="/写在使用es前/">写在使用es前</a></li><li class="post-list-item"><a class="post-list-link" href="/sql语法/">sql语法</a></li><li class="post-list-item"><a class="post-list-link" href="/mysql临时表/">mysql临时表</a></li><li class="post-list-item"><a class="post-list-link" href="/上传文件中中文名称的处理和python实现/">flask上传文件中文名称的处理</a></li><li class="post-list-item"><a class="post-list-link" href="/redis基本操作/">redis基本操作</a></li><li class="post-list-item"><a class="post-list-link" href="/redis对象/">redis对象</a></li><li class="post-list-item"><a class="post-list-link" href="/redis数据结构/">redis数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/redis高可用/">redis高可用</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">吃饭不喝汤.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>